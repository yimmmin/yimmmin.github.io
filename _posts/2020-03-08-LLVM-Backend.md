---
layout: post
title: LLVM Backend
date: 2020-03-11 02:26:00
categories: code
tags: 编译 LLVM Backend
excerpt: Original Tutorial 官方教程的描述是最简化的版本，且跟实际的文件结构有些出入，以下内容参考Mips架构的文件结构，记录实际编写一个XXX架构后端的过程。 Goal To write compiler backends that convert the LLVM Intermediate Representation (IR) to code for a specified machine or other languages. Prerequisite LLVM Language Reference Manual The LLVM...
---

[Original Tutorial](http://llvm.org/docs/WritingAnLLVMBackend.html#target-machine)

官方教程的描述是最简化的版本，且跟实际的文件结构有些出入，以下内容参考Mips架构的文件结构，记录实际编写一个XXX架构后端的过程。

### Goal

To write compiler backends that convert the LLVM Intermediate Representation (IR) to code for a specified machine or other languages.

### Prerequisite

- [LLVM Language Reference Manual](http://llvm.org/docs/LangRef.html)
- [The LLVM Target-Independent Code Generator](http://llvm.org/docs/CodeGenerator.html)
- [TableGen](http://llvm.org/docs/TableGen/index.html)
- [Writing an LLVM Pass](http://llvm.org/docs/WritingAnLLVMPass.html)

### Basic Steps

1. 创建目标机器子类 Create a subclass of the `TargetMachine` class that describes characteristics of your target machine.
- Copy existing examples of specific TargetMachine class and header files; for example, copy `MipsTargetMachine.cpp` and `MipsTargetMachine.h` and change the file names.
2. 描述寄存器 Describe the register set of the target.
- Use TableGen to generate code for register definition, register aliases, and register classes from a target-specific `RegisterInfo.td` input file. Write additional code for a subclass of the `TargetRegisterInfo` class that represents the class register file data used for register allocation and also describes the interactions between registers.
3. 描述指令 Describe the instruction set of the target.
- Use TableGen to generate code for target-specific instructions from target-specific versions of `TargetInstrFormats.td` and `TargetInstrInfo.td`. Write additional code for a subclass of the `TargetInstrInfo` class to represent machine instructions supported by the target machine.
4. 描述DGA到指令的转换 Describe the selection and conversion of the LLVM IR from a Directed Acyclic Graph (DAG) representation of instructions to native target-specific instructions.
- Use TableGen to generate code that matches patterns and selects instructions based on additional information in a target-specific version of TargetInstrInfo.td. Write code for `TargetISelDAGToDAG.cpp` to perform pattern matching and DAG-to-DAG instruction selection. Also write code in `TargetISelLowering.cpp` to replace or remove operations and data types that are not supported natively in a SelectionDAG.
5. 描述IR到汇编的转换 Write code for an assembly printer that converts LLVM IR to a GAS format.
- Add assembly strings to the instructions defined in TargetInstrInfo.td. Write code for a subclass of AsmPrinter that performs the LLVM-to-assembly conversion and a trivial subclass of `TargetAsmInfo`.
6. (Optional) Add support for subtargets.
7. (Optional) Add JIT support and create a machine code emitter.

### 1. 目标机器子类 TargetMachine Subclass

1. Create a subdirectory under `lib/Target` to hold all the files related.
- `lib/Target/XXX`
2. Create a `CMakeLists.txt & LLVMBuild.txt` . 
- 复制后将文件中的架构名称进行替换，根据架构描述，将文件中的内容进行增减。
3. Implement a subclass of `TargetMachine`.

    复制并修改两个文件`lib/Target/XXX/XXXTargetMachine.h & XXXTargetMachine.cpp`。除了替换架构名称，还有部分内容需要调整。

    XXXTargetMachine.h内容解释：
    - LLVMTargetMachine is designed as a base class for targets implemented with the LLVM target-independent code generator. It is defined as a subclass of TargetMachine in TargetMachine.h.
    - [ABI](https://baike.baidu.com/item/ABI/10912305)（Application Binary Interface，应用程序二进制接口），Mips分为o32、n32、n64三种。
    - ABI和big/little endian还涉及到`lib/Target/XXX/TargetInfo`目录下的文件，同样需要修改。例如默认XXX是32位及大端，后接关键字`64`、`el`则代表64位、小端。

    XXXTargetMachine.cpp内容解释：
    - The implementation of XXXTargetMachine must have access methods to obtain objects that represent target components. These methods are named `get*Info`, and are intended to obtain the instruction set (`getInstrInfo`), register set (`getRegisterInfo`), stack frame layout (`getFrameInfo`), and similar information. XXXTargetMachine must also implement the `getDataLayout` method to access an object with target-specific data characteristics, such as data type size and alignment requirements.

4. 完整、纯净地描述一个架构实在是有很多问题，我觉得先写后面的内容。

### 2. 寄存器描述 Register Descripction

Much of the code for registers, including register definition, register aliases, and register classes, is generated by TableGen from `XXXRegisterInfo.td` input files and placed in `XXXGenRegisterInfo.h.inc` and `XXXGenRegisterInfo.inc` output files.

1. 寄存器定义 Register Definition

    ```
    class Register<string n> {
      string Namespace = "";        //所属的命名空间，取XXX
      string AsmName = n;           //汇编名称，由字符n决定
      string Name = n;              //名称，由字符n决定
      int SpillSize = 0;            //溢出时保存寄存器所需的位数
      int SpillAlignment = 0;       //溢出时保存寄存器所要求的对齐
      list<Register> Aliases = [];  //别名
      list<Register> SubRegs = [];  //子寄存器
      list<int> DwarfNumbers = [];  //用于gcc、gdb等识别的内部编号
    }
    ```
    例如：
    ```
    def AL : Register<"AL">, DwarfRegNum<[0, 0, 0]>;
    ```
    通过继承可以增加Register定义时的参数输入或者进行子寄存器定义等，需要使用“let”覆盖初始赋值。
    ```
    class MipsReg<bits<16> Enc, string n> : Register<n> {
      let HWEncoding = Enc;
      let Namespace = "Mips";
    }
    ```
    TableGen generates a `TargetRegisterDesc` object for each register.
    ```
    struct TargetRegisterDesc {
      const char     *AsmName;      // Assembly language name for the register
      const char     *Name;         // Printable name for the reg (for debugging)
      const unsigned *AliasSet;     // Register Alias Set
      const unsigned *SubRegs;      // Sub-register set
      const unsigned *ImmSubRegs;   // Immediate sub-register set
      const unsigned *SuperRegs;    // Super-register set
    };
    ```
    其中AsmName和Name用于确定某个寄存器，剩余参数用于描述该寄存器与其他寄存器的关系。

    - GPR（General Purpose Register，通用寄存器）

2. 寄存器类定义 Register Class Definition

    The RegisterClass class is used to define an object that represents a group of related registers and also defines the default allocation order of the registers.
    ```
    class RegisterClass<string namespace,
    list<ValueType> regTypes, int alignment, dag regList> {
      string Namespace = namespace;
      list<ValueType> RegTypes = regTypes;
      int Size = 0;  // spill size, in bits; zero lets tblgen pick the size
      int Alignment = alignment;

      // CopyCost is the cost of copying a value between two registers
      // default value 1 means a single instruction
      // A negative value means copying is extremely expensive or impossible
      int CopyCost = 1;
      dag MemberList = regList;

      // for register classes that are subregisters of this class
      list<RegisterClass> SubRegClassList = [];

      code MethodProtos = [{}];  // to insert arbitrary code
      code MethodBodies = [{}];
    }
    ```
    To define a RegisterClass, use the following 4 arguments:
    - `namespace`.
    - A list of `ValueType` register type values that are defined in `include/llvm/CodeGen/ValueTypes.td`. Defined values include integer types (such as `i16`, `i32`, and `i1` for Boolean), floating-point types (`f32`, `f64`), and vector types (for example, `v8i16` for an 8 x `i16` vector).
    - `RegisterClass` specifies the alignment required of the registers when they are stored or loaded to memory.
    - `regList` specifies which registers are in this class. If an alternative allocation order method is not specified, then regList also defines the order of allocation used by the register allocator.Besides simply listing registers with `(add R0, R1, ...)`, more advanced set operators are available. See `include/llvm/Target/Target.td` for more information.

    Using `XXXRegisterInfo.td` with TableGen generates `XXXGenRegisterInfo.h.inc`, which is included in `XXXRegisterInfo.h`, and `XXXGenRegisterInfo.inc`, which is included in `XXXRegisterInfo.cpp`.

3. 完善寄存器描述子类 Implementation of Class XXXRegisterInfo

    对目标机器的寄存器子类`XXXRegisterInfo`的描述文件为`XXXRegisterInfo.h`和`XXXRegisterInfo.cpp`，根据需求对函数进行重载、增加，例如：
    - `getCalleeSavedRegs`： Returns a list of callee-saved registers in the order of the desired callee-save stack frame offset.
    - `getReservedRegs`: Returns a bitset indexed by physical register numbers, indicating if a particular register is unavailable.
    - `hasFP`: Return a Boolean indicating if a function should have a dedicated frame pointer register.
    - `eliminateCallFramePseudoInstr`: If call frame setup or destroy pseudo instructions are used, this can be called to eliminate them.
    - `eliminateFrameIndex`: Eliminate abstract frame indices from instructions that may use them.
    - `emitPrologue`: Insert prologue code into the function.
    - `emitEpilogue`: Insert epilogue code into the function.

### 参考连接

1. [ABI（应用程序二进制接口） - 百度百科](https://baike.baidu.com/item/ABI/10912305)
2. [MIPS ABI n32意味着什么？ - Trunk.Woo - 博客园](https://www.cnblogs.com/yorkwoo/p/4709772.html)